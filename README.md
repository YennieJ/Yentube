# <a href="https://yentube.store/s" target="_blank" rel="noreferrer"> ğŸ‘‰ğŸ» Yentube </a>

> ê°œì„  ì  : google-login-scopeì„ ì‚¬ìš©í•´ì„œ ìœ ì € ì •ë³´ ê°€ì ¸ì˜¤ê¸°

https://user-images.githubusercontent.com/108519185/232328497-3961aa85-a1d2-431c-8449-9e1f580ef114.mp4

https://user-images.githubusercontent.com/108519185/232318444-bf6e9c19-26fb-4de2-b60f-0d02d6bc0700.mp4

---

![react](https://img.shields.io/badge/-React-000000?logo=react&logoColor=61DAFB&style=for-the-badge)
![cssmodules](https://img.shields.io/badge/-cssmodules-000000?logo=cssmodules&logoColor=white&style=for-the-badge)
![javascript](https://img.shields.io/badge/-javascript-000000?logo=javascript&logoColor=F7DF1E&style=for-the-badge)

![axios](https://img.shields.io/badge/-axios-000000?logo=axios&logoColor=white&style=for-the-badge)
![reactquery](https://img.shields.io/badge/-reactquery-000000?logo=reactquery&logoColor=FF4154&style=for-the-badge)
![reacthookform](https://img.shields.io/badge/-reacthookform-000000?logo=reacthookform&logoColor=EC5990&style=for-the-badge)
![recoil](https://img.shields.io/badge/recoil-000000?style=for-the-badge&logo=data:image/svg+xml;base64,PHN2ZyBpZD0iQ2FscXVlXzEiIGRhdGEtbmFtZT0iQ2FscXVlIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDI1NS4yMSA2MjMuOTEiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDojMDA3YWY0fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0ibTc0LjYyIDI3Ny40NiAxLjI0LS4xMyAzNC43OC0zLjI4LTUzLjQ3LTU4LjY2QTk2LjQ3IDk2LjQ3IDAgMCAxIDMyIDE1MC4zSDNhMTI1LjMgMTI1LjMgMCAwIDAgMzIuOCA4NC41N1pNMTc3LjEzIDM0N2wtMzYgMy40IDUzLjMyIDU4LjUxQTk2LjQxIDk2LjQxIDAgMCAxIDIxOS42MyA0NzRoMjguOTJhMTI1LjI4IDEyNS4yOCAwIDAgMC0zMi43Ni04NC41N1oiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0yNTMuNjkgMjMxLjY4Yy02LjMzLTMxLjMtMzAuODktNTQuMDktNjIuNTctNTguMDdsLTYuMzUtLjc5YTQ5LjYxIDQ5LjYxIDAgMCAxLTQzLjM1LTQ5LjEzdi0yMGE1Mi43NSA1Mi43NSAwIDEgMC0yOC45MS0uMzZ2MjAuMzhhNzguNTYgNzguNTYgMCAwIDAgNjguNjUgNzcuODJsNi4zNi44YzIzLjI0IDIuOTIgMzQuNzggMjAgMzcuODMgMzUuMXMtLjkzIDM1LjMyLTIxLjIyIDQ3YTczLjgxIDczLjgxIDAgMCAxLTMwLjA2IDkuNjJsLTk1LjY2IDlhMTAyLjQ1IDEwMi40NSAwIDAgMC00MS44IDEzLjM4QzkgMzMyLjQ1LTQuODEgMzYzIDEuNTIgMzk0LjI5czMwLjg5IDU0LjA4IDYyLjU3IDU4LjA2bDYuMzUuOGE0OS42IDQ5LjYgMCAwIDEgNDMuMzUgNDkuMTJ2MThhNTIuNzUgNTIuNzUgMCAxIDAgMjguOTEuMjZ2LTE4LjI2YTc4LjU1IDc4LjU1IDAgMCAwLTY4LjY1LTc3LjgxbC02LjM2LS44Yy0yMy4yNC0yLjkyLTM0Ljc4LTIwLjA1LTM3LjgzLTM1LjExcy45My0zNS4zMiAyMS4yMi00N2E3My42OCA3My42OCAwIDAgMSAzMC4wNi05LjYzbDk1LjY2LTlhMTAyLjQ1IDEwMi40NSAwIDAgMCA0MS44LTEzLjM4YzI3LjY1LTE2LjAyIDQxLjQtNDYuNTQgMzUuMDktNzcuODZaIi8+PC9zdmc+)
![netlify](https://img.shields.io/badge/-netlify-000000?logo=netlify&logoColor=00C7B7&style=for-the-badge)

![googleads](https://img.shields.io/badge/-googleads-ffffff?logo=googleads&logoColor=4285F4&style=for-the-badge)
![responsiveUI](https://img.shields.io/badge/-ë°˜ì‘í˜•-ffffff?&style=for-the-badge)
![infinitescroll](https://img.shields.io/badge/-ë¬´í•œìŠ¤í¬ë¡¤-ffffff?logo=reactquery&logoColor=FF4154&style=for-the-badge)

---

## Google APIs + Axios + useContext

> Recoil vs Context : ContextëŠ” ë°ì´í„°ê°€ ë³€ê²½ ë˜ë©´ ê°ì‹¸ê³ ìˆëŠ” ì»´í¬ë„ŒíŠ¸ê°€ ë‹¤ì‹œ ë Œë”ë§ ë˜ì§€ë§Œ Recoilì€ ë°ì´í„°ë§Œ ë Œë”ë§í•œë‹¤.

 <br/>

1. src > api > YoutubeClient

```js
import axios from "axios";

// fetchë¥¼ ì‚¬ìš©í•˜ë©´ ì •ë³´ë¥¼ ë°›ì•„ ì˜¬ ë•Œë§ˆë‹¤ JSONìœ¼ë¡œ ë³€í™˜í•´ì•¼ í•œë‹¤ëŠ” ì ê³¼ catchë¡œ errorë¥¼ í•¸ë“¤ë§í•  ìˆ˜ ìˆì§€ë§Œ
// ë°±ì—”ë“œì—ì„œ ì •ë³´ë¥¼ ë°›ì•„ì˜¤ëŠ” ê²ƒ ëª¨ë‘ ì„±ê³µí–ˆë‹¤ê³  ì²˜ë¦¬í•˜ë¯€ë¡œ (200ëŒ€ë“  400ëŒ€ë“ ) thenì—ì„œ ê±¸ëŸ¬ì¤˜ì•¼ í•˜ëŠ”ë°(throwë¥¼ í†µí•´)
// ì´ê²ƒì„ í•´ê²°í•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ê²ƒì´ axios

export default class YoutubeClinet {
  // axios ìƒì„±
  constructor() {
    this.httpClient = axios.create({
      baseURL: "https://www.googleapis.com/youtube/v3/",
      params: { key: process.env.REACT_APP_YOUTUBE_API_KEY },
    });
  }

  // google apisì—ì„œ search,videos,channelsë¥¼ ë¶ˆëŸ¬ì˜¨ë‹¤.
  // paramsëŠ” src > api > Youtubeì—ì„œ ì „ë‹¬ ë°›ëŠ”ë‹¤.
  async search(params) {
    return this.httpClient.get("search", params);
  }

  async videos(params) {
    return this.httpClient.get("videos", params);
  }

  async channels(params) {
    return this.httpClient.get("channels", params);
  }
}
```

2. src > api > Youtube

```js
// google apis params í˜•ì‹ì— ë”°ë¦„.

export default class Youtube {
  // apiClinet === YoutubeClient
  constructor(apiClient) {
    this.apiClient = apiClient;
  }

  // #ì€ í”„ë¼ì´ë¹— í•¨ìˆ˜ë¡œ ì´ class ë‚´ë¶€ì—ì„  í˜¸ì¶œì´ ê°€ëŠ¥í•˜ë‚˜ ì™¸ë¶€ì—ì„  ë¶ˆê°€ëŠ¥
  async search(pageToken, keyword) {
    return keyword
      ? this.#searchByKeyword(pageToken, keyword)
      : this.#mostPopular(pageToken);
  }

  //ì±„ë„ ì‚¬ì§„
  async channelImageURL(id) {
    return this.apiClient
      .channels({ params: { part: "snippet", id } })
      .then((res) => res.data.items[0].snippet.thumbnails.default.url);
  }

  //ê²€ìƒ‰ ë‚´ìš©ê³¼ ê´€ë ¨ëœ ë¹„ë””ì˜¤
  async relatedVideo(id) {
    return this.apiClient
      .search({
        params: {
          part: "snippet",
          maxResults: 24,
          type: "video",
          regionCode: "KR",

          relatedToVideoId: id,
        },
      })
      .then((res) =>
        res.data.items.map((item) => ({ ...item, id: item.id.videoId }))
      );
  }

  //search data
  async #searchByKeyword(pageToken, keyword) {
    return this.apiClient
      .search({
        params: {
          part: "snippet",
          maxResults: 24,
          type: "video",
          q: keyword,
          regionCode: "KR",

          pageToken: pageToken && pageToken,
        },
      })

      .then((res) => res.data);
  }

  //videoList data
  async #mostPopular(pageToken) {
    return this.apiClient
      .videos({
        params: {
          part: "snippet",
          maxResults: 24,
          chart: "mostPopular",
          regionCode: "KR",

          pageToken: pageToken && pageToken,
        },
      })
      .then((res) => res.data);
  }
}
```

3. src > context > youtubeApiContext

```js
import { createContext, useContext } from "react";

import Youtube from "../api/youtube";
import YoutubeClient from "../api/youtubeClient";

// contextë€? props ì „ë‹¬ë¡œ stateë¥¼ ë³€í™”ì‹œí‚¤ì§€ ì•Šê³  provider ì•ˆì— ìˆëŠ” ëª¨ë“  componentì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.
const YoutubeApiContext = createContext();

const client = new YoutubeClient();
const youtube = new Youtube(client);

// App
export function YoutubeApiProvider({ children }) {
  return (
    <YoutubeApiContext.Provider value={{ youtube }}>
      {children}
    </YoutubeApiContext.Provider>
  );
}

// ì‚¬ìš©í•˜ëŠ” component
// Components > VideoItem > Components > ChannelInfo
// Pages > VideoDetail > Components > RelatedVideoList
// Pages > VideoList
export function useYoutubeApi() {
  return useContext(YoutubeApiContext);
}
```

## ë°˜ì‘í˜•

https://user-images.githubusercontent.com/108519185/232318292-07c55478-29cb-47d7-915b-99b70296cc3a.mov

## ë¬´í•œ ìŠ¤í¬ë¡¤(useInfiniteQuery) + Custom Hooks

```js
import React, { useState, useRef } from "react";

import { useInfiniteQuery } from "@tanstack/react-query";

import VideoItem from "Components/VideoItem/VideoItem";

const VideoList = () => {
  const [prevData, setPrevData] = useState();
  const [nextPageToken, setNextPageToken] = useState("");

  //api í˜¸ì¶œ
  const { youtube } = useYoutubeApi();

  //ë¬´í•œìŠ¤í¬ë¡¤ì„ êµ¬ë™í•˜ê¸°ìœ„í•œ useInfiniteQuery
  const {
    data: videos,
    fetchNextPage,
    hasNextPage,
  } = useInfiniteQuery(
    ["videos"],
    () =>
      youtube.search(nextPageToken).then((data) => {
        return (
          //ë§¤ë²ˆë°”ë€ŒëŠ” setNextPageTokenì„ ì €ì¥í•˜ê¸°ìœ„í•´
          setNextPageToken(data.nextPageToken),
          //infinityQueryë¥¼ ìœ„í•œ pageì •ë³´
          setPrevData(data.pageInfo),
          data.items
          //data
        );
      }),
    {
      staleTime: 1000 * 60 * 1,
      //reactQuery í•¨ìˆ˜
      getNextPageParam: (page, pages) => {
        //ì „ì²´ í˜ì´ì§€ ê°¯ìˆ˜
        const totalPages =
          prevData && prevData.totalResults / prevData.resultsPerPage;

        const nextPage = page.page + 1;
        return totalPages > pages.length ? nextPage : undefined;
      },
    }
  );

  // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ í™•ì¸
  const loadMoreRef = useRef();

  useIntersectionObserver({
    root: null,
    target: loadMoreRef,
    onIntersect: fetchNextPage,
    enabled: hasNextPage,
  });

  // Hooks íŒŒì¼ ì•ˆì— Custom Hooks
  // ë¬´í•œ ìŠ¤í¬ë¡¤
  function useIntersectionObserver({
    root,
    target,
    onIntersect,
    threshold = 1.0,
    rootMargin = "0px",
    enabled = true,
  }) {
    React.useEffect(() => {
      if (!enabled) {
        return;
      }

      const observer = new IntersectionObserver(
        (entries) =>
          entries.forEach((entry) => entry.isIntersecting && onIntersect()),
        {
          root: root && root.current,
          rootMargin,
          threshold,
        }
      );

      const el = target && target.current;

      if (!el) {
        return;
      }

      observer.observe(el);

      return () => {
        observer.unobserve(el);
      };
    }, [target, enabled, root, threshold, rootMargin, onIntersect]);
  }

  return (
    <>
      {videos && (
        <ul className={styles.videos}>
          {videos.pages.map((page) =>
            page.map((video) => <VideoItem key={video.id} video={video} />)
          )}
        </ul>
      )}

      <div ref={loadMoreRef} />
    </>
  );
};

export default VideoList;
```
